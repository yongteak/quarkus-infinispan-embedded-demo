### JGroups와 Infinispan클러스터링 구성간 충돌 위험
Infinispan과 JGroups는 밀접하게 연관되어 있습니다. Infinispan은 클러스터링과 분산 캐싱 기능을 제공하는 데이터 그리드 플랫폼이며, JGroups는 Java 기반의 메시징 라이브러리로, 멀티캐스트 또는 유니캐스트를 통해 Java 객체를 클러스터 내의 노드 간에 전송할 수 있게 해줍니다. 실제로, Infinispan은 클러스터 통신을 위해 내부적으로 JGroups를 사용합니다.
JGroups 라이브러리와 설정 추가 시 고려사항:
1. 버전 호환성: 프로젝트에 JGroups를 직접 추가할 때는 Infinispan이 사용하는 JGroups 버전과의 호환성을 확인해야 합니다. Infinispan과 함께 제공되는 JGroups 버전이 이미 프로젝트의 요구 사항을 충족시키는 경우, 별도로 JGroups를 추가하지 않는 것이 좋습니다.
2. 설정 충돌: Infinispan과 JGroups 모두 XML 또는 프로그래매틱 방식으로 구성할 수 있습니다. 프로젝트에 JGroups 설정을 추가할 때는 기존 Infinispan 구성과 충돌하지 않도록 주의해야 합니다. 예를 들어, 네트워크 설정, 클러스터 이름, 채널 설정 등이 서로 충돌하지 않도록 해야 합니다.
3. 리소스 사용: JGroups는 네트워크 통신을 위해 추가적인 리소스(예: 스레드, 메모리)를 사용합니다. 프로젝트에서 JGroups를 직접 사용할 경우, 이러한 리소스 사용이 시스템의 전체 성능에 영향을 줄 수 있으므로, 리소스 사용량을 모니터링하고 적절히 관리해야 합니다.
결론적으로, 프로젝트에 JGroups 라이브러리와 설정을 추가할 경우 충돌의 우려가 없지 않습니다. 그러나 적절한 버전 호환성 확인, 세심한 설정 관리, 그리고 리소스 사용에 대한 주의를 기울인다면, Infinispan과 JGroups를 함께 사용하여 강력한 클러스터링 및 메시징 솔루션을 구축할 수 있습니다. 프로젝트의 요구 사항에 따라 JGroups의 고급 기능을 활용하려는 경우, 이러한 고려사항을 충분히 검토한 후에 진행하는 것이 중요합니다.


### 모든 데이터 보장하기
동기화된 이벤트 리스너로 동작하도록 보장하기 위해서는 @Listener 어노테이션의 sync 속성을 true로 설정해야 합니다. 이 설정은 이벤트 리스너가 이벤트를 순차적으로 처리하도록 강제합니다. 즉, 한 이벤트의 처리가 완료되어야만 다음 이벤트가 처리됩니다. 이는 이벤트 처리 순서를 보장하지만, 동시 처리 성능에 영향을 줄 수 있습니다.

### 데이터 동기화 전략
Infinispan에서 @Listener(sync = true) 설정을 사용하면, 이벤트 처리가 동기적으로 수행되어 모든 노드에서 데이터가 동기화될 때까지 기다립니다. 이는 새로운 이벤트가 발생했을 때, 이전 이벤트가 모든 노드에 동기화될 때까지 처리가 대기 상태에 머무르게 합니다. 그러나 특정 노드가 다운되거나 타임아웃이 발생하는 경우, 이벤트 처리에 실패할 수 있으며, 이는 시스템의 가용성과 성능에 영향을 줄 수 있습니다.
이러한 문제를 해결하기 위한 전략 및 설정은 다음과 같습니다:
1. 타임아웃 설정: Infinispan은 네트워크 통신과 관련된 다양한 타임아웃 설정을 제공합니다. 예를 들어, sync 리스너의 타임아웃 값을 조정하여, 네트워크 지연이나 노드 다운 시나리오에서의 대응력을 개선할 수 있습니다.
2. 백업 전략: 데이터의 일관성을 유지하기 위해, Infinispan은 데이터 복제 및 분산 캐시 전략을 제공합니다. 예를 들어, 캐시 구성에서 numOwners 속성을 사용하여 데이터의 복제본 수를 지정할 수 있으며, 이는 특정 노드가 실패했을 때 데이터 손실 위험을 줄여줍니다.
3. 분할 뇌(split-brain) 보호: 클러스터 환경에서 노드 간의 네트워크 분할이 발생했을 때, 데이터 일관성을 유지하기 위한 전략이 필요합니다. Infinispan은 분할 뇌 보호 메커니즘을 제공하여, 네트워크 분할 상황에서도 데이터 일관성을 유지할 수 있도록 합니다.
4. 비동기 리스너 사용 고려: 동기 리스너가 필수적이지 않은 경우, 비동기 리스너(sync = false)를 사용하여 이벤트 처리 성능을 향상시킬 수 있습니다. 비동기 처리는 이벤트 처리 순서를 엄격하게 보장하지는 않지만, 전체 시스템의 처리량과 응답성을 개선할 수 있습니다.
이러한 전략과 설정은 시스템의 요구 사항과 환경에 따라 적절히 조합하여 사용해야 합니다. Infinispan 문서와 구성 가이드를 참조하여, 시스템의 특성에 맞는 최적의 구성을 결정하는 것이 중요합니다.


### @Listener 어노테이션
@Listener 어노테이션은 Infinispan에서 이벤트 리스너를 정의할 때 사용되며, 여러 설정 옵션을 제공합니다. 이 옵션들을 통해 리스너의 동작 방식을 세밀하게 제어할 수 있습니다. 다음은 @Listener 어노테이션의 주요 설정 옵션들에 대한 설명입니다:
1. sync: 이 옵션은 리스너가 이벤트를 동기적으로(true) 또는 비동기적으로(false) 처리할지를 결정합니다. 기본값은 true입니다. 동기 리스너는 이벤트 처리가 완료될 때까지 다른 이벤트의 처리를 차단하지만, 비동기 리스너는 그렇지 않습니다.
2. clustered: 클러스터 환경에서 리스너가 클러스터 전체에 걸쳐 이벤트를 수신할지(true), 아니면 단지 로컬 노드에서 발생한 이벤트만을 수신할지(false)를 결정합니다. 기본값은 false입니다. true로 설정하면, 클러스터 내의 모든 노드에서 발생하는 이벤트를 리스너가 수신할 수 있습니다.
3. primaryOnly: 이 옵션은 분산 캐시 환경에서 사용됩니다. true로 설정하면, 리스너는 오직 주(primary) 소유자에서 발생한 이벤트만을 수신합니다. 기본값은 false이며, 이 경우 모든 업데이트(주 소유자와 백업 소유자 모두)에 대한 이벤트를 리스너가 수신할 수 있습니다.
4. includeCurrentState: 이 옵션을 true로 설정하면, 리스너 등록 시 현재 캐시 상태에 대한 이벤트들이 리스너에게 전송됩니다. 즉, 리스너가 등록되는 시점에 이미 캐시에 존재하는 항목들에 대한 정보를 리스너가 받게 됩니다. 기본값은 false입니다.
5. observation: 이 옵션은 리스너가 이벤트를 관찰하는 방식을 결정합니다. Observation.POST (기본값)는 실제 이벤트가 발생한 후에 리스너가 알림을 받도록 설정합니다. 반면, Observation.PRE는 이벤트가 발생하기 직전에 리스너가 알림을 받도록 설정합니다.
이러한 설정 옵션들을 통해, 리스너의 동작을 애플리케이션의 요구 사항에 맞게 세밀하게 조정할 수 있습니다. 리스너의 동작 방식을 결정할 때는 이벤트 처리의 성능과 일관성 요구 사항을 고려해야 합니다.
관련 자료
https://infinispan.org/docs/stable/titles/configuring/configuring.html

### primaryOnly
Infinispan에서 primaryOnly 옵션은 분산 캐시 환경에서 사용되며, 이벤트 리스너가 주(primary) 데이터 소유자에서 발생한 이벤트만을 수신하도록 설정합니다. 이 설정은 @Listener 어노테이션 내에서 사용되며, 리스너의 이벤트 수신 범위를 제한하는 데 사용됩니다.
데이터를 여러 노드에 분산 저장하기 위해 Consistent Hashing(일관된 해싱)을 사용합니다. 이 방식에서 각 캐시 엔트리는 특정 노드에 '주(primary)' 소유자로 할당되며, 추가적으로 하나 이상의 백업(backup) 복사본이 다른 노드에 저장될 수 있습니다. 이는 고가용성과 데이터 내구성을 보장하기 위함입니다.
주(primary) 소유자: 캐시된 데이터의 주 복사본을 보유하는 노드입니다. 데이터의 읽기 및 쓰기 작업은 주로 이 노드를 통해 처리됩니다.
백업(backup) 소유자: 주 소유자에 이어 데이터의 추가 복사본을 보유하는 노드입니다. 이는 데이터의 안정성과 가용성을 높이기 위해 사용됩니다.
primaryOnly=true로 설정할 경우, 리스너는 오직 주 소유자 노드에서 발생한 이벤트에 대해서만 알림을 받습니다. 이는 네트워크 트래픽과 시스템 부하를 줄이는 데 도움이 될 수 있으나, 모든 데이터 변경 사항을 추적하려는 경우에는 적합하지 않을 수 있습니다.

주(Primary) 소유자 노드는 알고리즘에 의해 자동으로 선택됩니다. Infinispan에서는 일관된 해싱(Consistent Hashing) 알고리즘을 사용하여 각 캐시 엔트리의 주 소유자를 결정합니다. 이 방식은 분산 캐시 시스템에서 데이터를 여러 노드에 균등하게 분배하고, 노드 추가나 제거 시에도 데이터 재분배를 최소화하는 데 도움을 줍니다.

### includeCurrentState
includeCurrentState=true로 설정되어 있을 때, 해당 옵션은 리스너가 등록될 때 현재 캐시에 있는 모든 데이터에 대한 이벤트를 리스너에게 전송하도록 지시합니다. 그러나 이것이 해당 노드가 네트워크에 연결될 때 모든 데이터를 "다운로드"한다는 것을 의미하지는 않습니다. 
이 설정은 리스너가 초기화될 때 현재 캐시 상태에 대한 스냅샷을 받게 됨을 의미합니다. 이 스냅샷은 캐시에 이미 존재하는 각 항목에 대한 이벤트를 생성하여, 리스너가 현재 캐시의 상태를 파악할 수 있도록 합니다.
이 기능은 주로 캐시의 현재 상태를 모니터링하거나, 리스너가 등록된 후에도 캐시의 전체 상태를 반영해야 하는 경우에 유용합니다. 예를 들어, 캐시의 전체 내용을 로드하거나, 캐시에 있는 모든 항목에 대해 특정 작업을 수행해야 할 때 사용할 수 있습니다.
SYNC 모드를 사용할 때, "클러스터 내의 모든 노드에 동기적으로 반영된다"는 표현은 모든 노드에 데이터가 복제된다는 의미가 아닙니다. Infinispan은 일반적으로 Consistent Hashing 알고리즘을 사용하여 데이터를 클러스터 내의 특정 노드(또는 노드 그룹)에 분산 저장합니다. SYNC 모드에서의 "동기적으로 반영된다"는 것은 데이터의 변경 사항이 해당 데이터를 소유하고 있는 노드(들)에 동기적으로 적용되어야 함을 의미합니다. 즉, 데이터의 업데이트가 해당 데이터의 소유자 노드와 백업 노드(들)에 동기적으로 적용되고, 이 작업이 완료될 때까지 작업 요청을 한 클라이언트는 대기 상태에 있게 됩니다.
이러한 방식은 데이터 일관성을 보장하지만, 네트워크 지연이나 노드 처리 속도에 따라 성능에 영향을 줄 수 있습니다. owners 속성을 통해 데이터가 몇 개의 노드에 복제될지 설정할 수 있으며, 이는 데이터의 가용성과 일관성을 관리하는 데 중요한 역할을 합니다. 그러나 실제로 모든 노드에 데이터가 복제되는 것은 아니며, Consistent Hashing을 통해 효율적으로 데이터를 분산하여 관리합니다.

### owners
owners 속성은 Infinispan에서 분산 캐시를 구성할 때 사용되며, 특정 데이터 항목(엔트리)이 클러스터 내 몇 개의 노드에 복제되어 저장될지를 결정합니다. 예를 들어, owners가 2로 설정되어 있다면, 각 데이터 항목은 원본 노드와 한 개의 백업 노드를 포함하여 총 두 노드에 저장됩니다. 이는 데이터의 가용성을 높이기 위해 사용되며, 어떤 노드가 실패하더라도 데이터를 안전하게 보호할 수 있도록 합니다.
owners의 값과 노드 클러스터의 개수와의 연관 관계는 다음과 같습니다:
클러스터 내 노드 수보다 owners 값이 작거나 같은 경우: 설정된 owners 수만큼 데이터 복제가 이루어집니다. 예를 들어, 클러스터에 5개의 노드가 있고 owners가 3으로 설정된 경우, 각 데이터 항목은 원본 포함 총 3개의 노드에 저장됩니다.
클러스터 내 노드 수보다 owners 값이 큰 경우: 실제 데이터 복제는 클러스터 내 노드 수에 의해 제한됩니다. 예를 들어, 클러스터에 3개의 노드만 있고 owners가 4로 설정된 경우, 가능한 모든 노드(즉, 3개 노드)에 데이터가 복제됩니다. 이 경우 owners 설정이 클러스터의 노드 수를 초과하기 때문에, 모든 노드가 데이터의 복제본을 가지게 됩니다.
owners 설정은 데이터의 가용성과 일관성을 관리하는 데 중요한 역할을 합니다. 높은 owners 값은 더 높은 데이터 가용성을 의미하지만, 동시에 더 많은 네트워크 트래픽과 저장 공간을 요구합니다. 따라서, 이 값을 설정할 때는 클러스터의 크기, 네트워크 대역폭, 저장 공간의 가용성, 그리고 애플리케이션의 요구 사항을 고려해야 합니다.

### 런타임 설정
${infinispan.cluster.name:local}와 ${infinispan.node.name:}와 같은 표현은 Infinispan 설정 파일에서 사용되는 속성 대체(placeholder) 문법입니다. 이 문법은 Infinispan이나 JGroups 설정 파일 내에서 환경 변수나 시스템 속성으로부터 값을 동적으로 받아오기 위해 사용됩니다. 이러한 속성 값은 일반적으로 다음과 같은 방법으로 정의될 수 있습니다:
1. 환경 변수: 애플리케이션을 실행하기 전에 운영 체제의 환경 변수로 정의됩니다. 예를 들어, Linux나 macOS에서는 터미널을 통해 export infinispan.cluster.name=myCluster와 같이 설정할 수 있습니다. Windows에서는 set infinispan.cluster.name=myCluster 명령을 사용합니다.
2. 시스템 속성: Java 애플리케이션 실행 시 JVM(Java Virtual Machine) 옵션으로 전달됩니다. 예를 들어, java -Dinfinispan.cluster.name=myCluster -jar myapp.jar와 같이 애플리케이션을 실행할 때 시스템 속성을 설정할 수 있습니다.
3. 프로그래매틱 방식: 애플리케이션 코드 내에서 직접 설정할 수도 있습니다. 예를 들어, Java에서는 System.setProperty("infinispan.cluster.name", "myCluster")를 호출하여 시스템 속성을 설정할 수 있습니다.
위의 예시에서 ${infinispan.cluster.name:local}는 infinispan.cluster.name 속성을 참조하며, 이 속성이 정의되어 있지 않은 경우 기본값으로 local을 사용하라는 의미입니다. 마찬가지로, ${infinispan.node.name:}는 infinispan.node.name 속성을 참조하며, 기본값이 명시되어 있지 않기 때문에 이 속성이 정의되어 있지 않으면 빈 문자열을 사용하게 됩니다.
이러한 방식은 설정 파일을 보다 유연하게 관리할 수 있게 해주며, 다양한 환경이나 조건에서 애플리케이션을 실행할 때 유용하게 사용될 수 있습니다.

Quarkus 애플리케이션을 개발 모드(quarkus dev)로 실행할 때 환경 변수나 시스템 속성을 사용하여 설정 값을 제공할 수 있습니다. 이는 Quarkus가 제공하는 유연한 구성 시스템을 통해 가능합니다. Quarkus는 실행 시간에 환경 변수, 시스템 속성, application.properties 파일 등 다양한 소스에서 구성 값을 읽어올 수 있습니다.
시스템 속성을 사용하는 경우
Quarkus 애플리케이션을 실행할 때 JVM 옵션을 통해 시스템 속성을 설정할 수 있습니다. 예를 들어, infinispan.cluster.name과 infinispan.node.name 속성을 설정하려면 다음과 같이 실행합니다:
./mvnw quarkus:dev -Dinfinispan.cluster.name=myCluster -Dinfinispan.node.name=node1
이 명령은 Maven을 사용하는 경우의 예시이며, Gradle을 사용하는 경우에는 다음과 같이 실행할 수 있습니다:
./gradlew quarkusDev -Dinfinispan.cluster.name=myCluster -Dinfinispan.node.name=node1
환경 변수를 사용하는 경우
환경 변수를 통해 이러한 속성을 설정할 수도 있습니다. 환경 변수는 운영 체제 레벨에서 설정되며, Quarkus 애플리케이션은 이러한 환경 변수를 자동으로 감지하여 해당 값으로 구성을 적용할 수 있습니다. 예를 들어, Linux나 macOS에서는 터미널을 통해 다음과 같이 설정할 수 있습니다:
export INFINISPAN_CLUSTER_NAME=myCluster
export INFINISPAN_NODE_NAME=node1
./mvnw quarkus:dev

Windows에서는 다음과 같이 설정합니다:
set INFINISPAN_CLUSTER_NAME=myCluster
set INFINISPAN_NODE_NAME=node1
mvnw quarkus:dev

Quarkus는 환경 변수 이름에서 점(.)을 언더스코어(_)로 변환하고 대문자로 변환하는 규칙을 사용합니다. 따라서 infinispan.cluster.name은 환경 변수로 INFINISPAN_CLUSTER_NAME으로 지정됩니다.
이러한 방법을 통해 Quarkus 애플리케이션의 개발 모드에서도 Infinispan 관련 설정을 유연하게 제공할 수 있습니다.


export ORACLIZER_HTTP_PORT=8081
export ORACLIZER_API_PORT=8091
export INFINISPAN_CLUSTER_NAME=cluster1
export INFINISPAN_NODE_NAME=node1
quarkus dev

export ORACLIZER_HTTP_PORT=8082
export ORACLIZER_API_PORT=8092
export INFINISPAN_CLUSTER_NAME=cluster1
export INFINISPAN_NODE_NAME=node2
quarkus dev


export ORACLIZER_HTTP_PORT=8083
export ORACLIZER_API_PORT=8093
export INFINISPAN_CLUSTER_NAME=cluster1
export INFINISPAN_NODE_NAME=node3
quarkus dev




### 튜닝
https://infinispan.org/docs/stable/titles/tuning/tuning.html